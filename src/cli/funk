<?php // Define default directories and check whether CLI or
// in Web Browser mode (only JSON is allowed in Browser mode)
// After that we set the default values for command & arguments
define('PROJECT_DIR', dirname(__DIR__));
define('BACKUPS_DIR', PROJECT_DIR . '/backups');
define('BATTERIES_DIR', PROJECT_DIR . '/batteries');
define('BATTERIES_MIDDLEWARES_DIR', BATTERIES_DIR . '/middlewares');
define('BATTERIES_PIPELINE_DIR', BATTERIES_DIR . '/pipeline');
define('BATTERIES_PIPELINE_REQUEST_DIR', BATTERIES_PIPELINE_DIR . '/request');
define('BATTERIES_PIPELINE_POST_REQUEST_DIR', BATTERIES_PIPELINE_DIR . '/post-request');
define('CLI_DIR', __DIR__);
define('FUNKPHP_DIR', PROJECT_DIR . '/funkphp');
define('FUNKPHP_INTERNALS_DIR', FUNKPHP_DIR . '/_internals');
define('FUNKPHP_INTERNALS_COMPILED_DIR', FUNKPHP_INTERNALS_DIR . '/compiled');
define('FUNKPHP_CACHED_DIR', FUNKPHP_DIR . '/_cached');
define('FUNKPHP_CACHED_FILES_DIR', FUNKPHP_CACHED_DIR . '/files');
define('FUNKPHP_CACHED_JSON_DIR', FUNKPHP_CACHED_DIR . '/json');
define('FUNKPHP_CACHED_PAGES_DIR', FUNKPHP_CACHED_DIR . '/pages');
define('FUNKPHP_CONFIG_DIR', FUNKPHP_DIR . '/config');
define('FUNKPHP_CONFIG_BLOCKED_DIR', FUNKPHP_CONFIG_DIR . '/blocked');
define('FUNKPHP_CONFIG_VALID_DIR', FUNKPHP_CONFIG_DIR . '/valid');
define('FUNKPHP_MIDDLEWARES_DIR', FUNKPHP_DIR . '/middlewares');
define('FUNKPHP_PAGE_DIR', FUNKPHP_DIR . '/page');
define('FUNKPHP_PAGE_COMPLETE_DIR', FUNKPHP_PAGE_DIR . '/complete');
define('FUNKPHP_PAGE_COMPONENTS_DIR', FUNKPHP_PAGE_DIR . '/components');
define('FUNKPHP_PAGE_PARTIALS_DIR', FUNKPHP_PAGE_DIR . '/partials');
define('FUNKPHP_PIPELINE_DIR', FUNKPHP_DIR . '/pipeline');
define('FUNKPHP_PIPELINE_REQUEST_DIR', FUNKPHP_PIPELINE_DIR . '/request');
define('FUNKPHP_PIPELINE_POST_REQUEST_DIR', FUNKPHP_PIPELINE_DIR . '/post-request');
define('FUNKPHP_ROUTES_DIR', FUNKPHP_DIR . '/routes');
define('FUNKPHP_SQL_DIR', FUNKPHP_DIR . '/sql');
define('FUNKPHP_VALIDATION_DIR', FUNKPHP_DIR . '/validation');
define('GUI_DIR', PROJECT_DIR . '/gui');
define('PUBLIC_DIR', PROJECT_DIR . '/public_html');
define('SCHEMA_DIR', PROJECT_DIR . '/schema');
define('TEMPLATE_DIR', PROJECT_DIR . '/template');
define('TEST_DIR', PROJECT_DIR . '/test');
$JSON = false;
$command = null;
$arg1 = null;
$arg2 = null;
$arg3 = null;
$arg4 = null;
$arg5 = null;

// Define message types and ANSI colors for CLI output
// but that can also be parsed by returned JSON Response
define('MSG_TYPE_ERROR', 'ERROR');
define('MSG_TYPE_SUCCESS', 'SUCCESS');
define('MSG_TYPE_INFO', 'INFO');
define('MSG_TYPE_WARNING', 'WARNING');
define('MSG_TYPE_IMPORTANT', 'IMPORTANT');
define('MSG_TYPE_SYNTAX_ERROR', 'SYNTAX_ERROR');
define('ANSI_RED', "\033[31m");
define('ANSI_GREEN', "\033[32m");
define('ANSI_YELLOW', "\033[33m");
define('ANSI_BLUE', "\033[34m");
define('ANSI_RESET', "\033[0m");
global $funk_response_messages;
$funk_response_messages = [];

// CLI Mode
if (php_sapi_name() === 'cli') {
    $command = $argv[1] ?? null;
    $arg1 = $argv[2] ?? null;
    $arg2 = $argv[3] ?? null;
    $arg3 = $argv[4] ?? null;
    $arg4 = $argv[5] ?? null;
    $arg5 = $argv[6] ?? null;
    $arg6 = $argv[7] ?? null;
    if (is_string($command)) {
        $command = strtolower($command);
    }
    if (is_string($arg1)) {
        $arg1 = strtolower($arg1);
    }
    if (is_string($arg2)) {
        $arg2 = strtolower($arg2);
    }
    if (is_string($arg3)) {
        $arg3 = strtolower($arg3);
    }
    if (is_string($arg4)) {
        $arg4 = strtolower($arg4);
    }
    if (is_string($arg5)) {
        $arg5 = strtolower($arg5);
    }
    if (is_string($arg6)) {
        $arg6 = strtolower($arg6);
    }
}
// JSON Mode
else {
    $JSON = true;
    header('Content-Type: application/json');
    $payload = json_decode(file_get_contents('php://input'), true) ?? [];
    $command = $payload['command'] ?? null;
    $arg1 = $payload['arg1'] ?? null;
    $arg2 = $payload['arg2'] ?? null;
    $arg3 = $payload['arg3'] ?? null;
    $arg4 = $payload['arg4'] ?? null;
    $arg5 = $payload['arg5'] ?? null;
    $arg6 = $payload['arg6'] ?? null;
    if (is_string($command)) {
        $command = strtolower($command);
    }
    if (is_string($arg1)) {
        $arg1 = strtolower($arg1);
    }
    if (is_string($arg2)) {
        $arg2 = strtolower($arg2);
    }
    if (is_string($arg3)) {
        $arg3 = strtolower($arg3);
    }
    if (is_string($arg4)) {
        $arg4 = strtolower($arg4);
    }
    if (is_string($arg5)) {
        $arg5 = strtolower($arg5);
    }
    if (is_string($arg6)) {
        $arg6 = strtolower($arg6);
    }
}
define("JSON_MODE", $JSON);
// If we are in JSON_MODE We then check that the REMOTE_ADDR is set and is either
// localhost or 127.0.0.1 since this should ONLY be ran in local development
if (JSON_MODE) {
    if (!isset($_SERVER['REMOTE_ADDR']) || !in_array($_SERVER['REMOTE_ADDR'], ['127.0.0.1', 'localhost'])) {
        http_response_code(403);
        echo json_encode(['error' => 'FunkCLI will ONLY accept using `127.0.0.1` or `localhost` as your Local IP!']);
        exit;
    }
    if (!isset($_SERVER['HTTP_ACCEPT']) || $_SERVER['HTTP_ACCEPT'] !== 'application/json') {
        http_response_code(406);
        echo json_encode(['error' => 'FunkCLI will ONLY accept `application/json` as value for the `Accept` Header!']);
        exit;
    }
}

// Try including files or throw an error if they are not found
if (
    !file_exists(CLI_DIR . '/cli_funs.php')
    || !file_exists(CLI_DIR . '/cli_funs2.php')
) {
    if (JSON_MODE) {
        http_response_code(500);
        echo json_encode([
            'type' => 'ERROR',
            'message' => 'FunkPHP CLI Function File(s) - either `cli_funs.php`, `cli_funs2.php` or both - NOT FOUND in `src/cli` Directory!'
        ]);
        exit;
    } else {
        echo "\033[31m[FunkCLI - ERROR]: FunkPHP CLI Function File(s) - either `cli_funs.php`, `cli_funs2.php` or both - NOT FOUND in `src/cli` Directory!\n\033[0m";
        exit;
    }
}
include CLI_DIR . '/cli_funs.php';
include CLI_DIR . '/cli_funs2.php';

// Load the settings file if it exists, otherwise use default settings
$settings = include CLI_DIR . '/funksettings' ?? [
    // Default settings for FunkCLI. "ALWAYS_BACKUP_IN" is a list of all the backup settings for the CLI.
    // It is used to determine which files should be backed up when the CLI runs backup-related commands.
    // DO NOT DELETE THIS PART. IT IS REQUIRED FOR THE CLI TO WORK PROPERLY. Change values to true or false.
    // Default is to always backup everything except the actual data handler files and middleware files as of now.
    "ALWAYS_BACKUP_IN" =>
    [
        "COMPILED_IN_BACKUPS" => false,
        "COMPILED_IN_FINAL_BACKUPS" => false,
        "DATA_IN_BACKUPS" => false,
        "DATA_IN_FINAL_BACKUPS" => false,
        "DATA_HANDLERS_IN_BACKUPS" => false,
        "DATA_HANDLERS_IN_FINAL_BACKUPS" => false,
        "DATA_MWS_IN_BACKUPS" => false,
        "DATA_MWS_IN_FINAL_BACKUPS" => false,
        "PAGES_IN_BACKUPS" => false,
        "PAGES_IN_FINAL_BACKUPS" => false,
        "PAGES_HANDLERS_IN_BACKUPS" => false,
        "PAGES_HANDLERS_IN_FINAL_BACKUPS" => false,
        "PAGES_MWS_IN_BACKUPS" => false,
        "PAGES_MWS_IN_FINAL_BACKUPS" => false,
        "ROUTES_IN_BACKUPS" => false,
        "ROUTES_IN_FINAL_BACKUPS" => false,
        "ROUTES_HANDLERS_IN_BACKUPS" => false,
        "ROUTES_HANDLERS_IN_FINAL_BACKUPS" => false,
        "ROUTES_MWS_IN_BACKUPS" => false,
        "ROUTES_MWS_IN_FINAL_BACKUPS" => false,
        "ALLOW_COMPLETE_BACKUP_DELETION" => false,
    ],
];

// All available dirs to use for the CLI
// & exact file paths to use for the CLI
$dirs = [
    "cli" => CLI_DIR . '/',
    "config" => FUNKPHP_DIR . '/config/',
    "config_blocked" => FUNKPHP_DIR . '/config/blocked/',
    "config_valid" => FUNKPHP_DIR . '/config/valid/',
    "_internals" => FUNKPHP_DIR . '/_internals/',
    "batteries" => FUNKPHP_DIR . '/_internals/batteries/',
    "compiled" => FUNKPHP_DIR . '/_internals/compiled/',
    "functions" => FUNKPHP_DIR . '/_internals/functions/',
    "_BACKUPS" => BACKUPS_DIR . '/',
    "pipeline" => FUNKPHP_DIR . '/pipeline/',
    "request" => FUNKPHP_DIR . '/pipeline/request/',
    "pipeline-request" => FUNKPHP_DIR . '/pipeline/request/',
    "post-request" => FUNKPHP_DIR . '/pipeline/post-request/',
    "pipeline-post-request" => FUNKPHP_DIR . '/pipeline/post-request/',
    "pipelines" => FUNKPHP_DIR . '/pipeline/',
    "routes" => FUNKPHP_DIR . '/routes/',
    "middlewares" => FUNKPHP_DIR . '/middlewares/',
    "pages" => FUNKPHP_DIR . '/page/',
    "p_parts" => FUNKPHP_DIR . '/pages/partials/',
    "p_components" => FUNKPHP_DIR . '/page/components/',
    "p_complete" => FUNKPHP_DIR . '/page/complete/',
    "templates" => PROJECT_DIR . '/template/',
    "tests" => PROJECT_DIR . '/test/',
    "schemas" => PROJECT_DIR . '/schema/',
    "sql" => FUNKPHP_DIR . '/sql/',
    'validations' => FUNKPHP_DIR . '/validation/',
    "backups_finals" => BACKUPS_DIR . '/_FINAL_BACKUPS/',
    "backups_compiled" => BACKUPS_DIR . '/compiled/',
    "backups_routes" => BACKUPS_DIR . '/config/',
    "backups_data" => BACKUPS_DIR . '/data/',
    "backups_pages" => BACKUPS_DIR . '/page/',
    "backups_handlers" => BACKUPS_DIR . '/handler/',
    "backups_middlewares" => BACKUPS_DIR . '/middlewares/',
    "backups_templates" => BACKUPS_DIR . '/template/',
    "backups_cached" => BACKUPS_DIR . '/cached/',
    "backups_config" => BACKUPS_DIR . '/config/',
    "backups_pipeline" => BACKUPS_DIR . '/pipeline/',
    "backups_sql" => BACKUPS_DIR . '/sql/',
    "backups_tests" => BACKUPS_DIR . '/test/',
    "backups_validations" => BACKUPS_DIR . '/validation/',
];
$exactFiles = [
    "troute_route" => $dirs['compiled'] . "troute_route.php",
    "single_pipeline" => $dirs['pipeline'] . "pipeline.php",
    "single_routes" => $dirs['routes'] . "routes.php",
    "tables" => $dirs['config'] . "tables.php",
    "db_local" => $dirs['config'] . "db_config.php",
    "supported_mysql_data_types" => $dirs['config_valid'] . "valid_mysql_datatypes.php",
];

// List of all functions that are reserved for the framework and
// should not be used in the application code. They are checked against
// when adding any new kind of function that is already reserved.
$reserved_functions = [];
if (file_exists_is_readable_writable(CLI_DIR . '/cli_reserved.php')) {
    $reserved_functions = include_once CLI_DIR . '/cli_reserved.php';
} else {
    cli_info_without_exit("Reserved Functions List File `cli_reserved.php` NOT FOUND! Attempting to generate a new one...");
    $reserved_functions = cli_update_reserved_functions_list_and_return_as_array();
    cli_success_without_exit("Reserved Functions List File `cli_reserved.php` Generated Successfully. Continuing...");
}
// First restore the folders if they don't exist
cli_restore_default_folders_and_files();

// Load current pipeline, routes, data and pages before processing any commands
$singlePipeline = include FUNKPHP_DIR . '/pipeline/pipeline.php' ?? [
    'pipeline' =>
    [
        'request' =>
        [
            0 => 'pl_https_redirect',
            1 => 'pl_run_ini_sets',
            2 => 'pl_set_session_cookie_params',
            3 => 'pl_db_connect',
            4 => 'pl_headers_set',
            5 => 'pl_headers_remove',
            6 => 'pl_start_session',
            7 => 'pl_prepare_uri',
            8 => 'pl_match_denied_exact_ips',
            9 => 'pl_match_denied_methods',
            10 => 'pl_match_denied_uas',
            11 => 'pl_match_route',
            12 => 'pl_run_matched_route_middlewares',
            13 => 'pl_run_matched_route_handler',
            14 => 'pl_run_matched_data_handler',
        ],
        'post-request' => [],
    ],
    'no_match' =>
    [
        'handler' => [
            'json' =>
            [],
            'page' =>
            [],
        ],
        'page' => [
            'json' =>
            [],
            'page' =>
            [],
        ],
    ],
];
$singleRoutesRoute = include FUNKPHP_DIR . '/routes/routes.php' ?? [
    'ROUTES' => ['GET' => [], 'POST' => [], 'PUT' => [], 'DELETE' => [], 'PATCH' => []]
];
$tablesAndRelationshipsFile = include FUNKPHP_DIR . '/config/tables.php' ?? [
    'tables' => [],
    'relationships' => [],
    'mappings' => [],
];
$mysqlDataTypesFile = include FUNKPHP_DIR . '/config/valid/valid_mysql_datatypes.php' ?? [
    'STRINGS' => [],
    'NUMBERS' => [],
    'INTS' => [],
    'FLOATS' => [],
    'DATETIMES' => [],
    'BLOBS' => []
];
$mysqlOperatorSyntax = include FUNKPHP_DIR . '/config/valid/valid_mysql_operators.php' ?? [
    'arithmetic' => [
        '+' => [],
        '-' => [],
        '*' => [],
        '/' => [],
        '%' => [],
    ],
    'bitwise' => [
        '&' => [],
        '|' => [],
        '^' => [],
    ],
    'comparison' => [
        '=' => [],
        '!=' => [],
        '<>' => [],
        '>' => [],
        '>=' => [],
        '<' => [],
        '<=' => [],
        'IS' => [],
    ],
    'compound' => [
        '+=' => [],
        '-=' => [],
        '*=' => [],
        '/=' => [],
        '%=' => [],
        '&=' => [],
        '^-=' => [],
        '|*=' => [],
    ],
    'logical' => [
        'ALL' => [],
        'AND' => [],
        'ANY' => [],
        'BETWEEN' => [],
        'EXISTS' => [],
        'IN' => [],
        'LIKE' => [],
        'NOT' => [],
        'OR' => [],
        'SOME' => [],
    ],
];

// Catch when no command is provided or is not a non-empty string
if (!isset($command)) {
    cli_err_syntax_without_exit("No command provided! Please provide a Command to execute with up to 6 arguments!");
    if (JSON_MODE) {
        cli_info("Use the following JSON format: `{ \"command\": \"<command>:<first_param>\", \"arg1\": \"<arg1>\", \"arg2\": \"<arg2>\", \"arg3\": \"<arg3>\", \"arg4\": \"<arg4>\", \"arg5\": \"<arg5>\", \"arg6\": \"<arg6>\" }`");
    } else {
        cli_info("Type a Command and then up to 6 arguments, like this: `funk <command:first_param> <arg1> <arg2> <arg3> <arg4> <arg5> <arg6>`");
    }
}
if (!is_string($command) || empty($command)) {
    cli_err_syntax_without_exit("Command must be a Non-Empty String! Please provide a valid Command with up to 6 arguments!");
    if (JSON_MODE) {
        cli_info("Use the following JSON format: `{ \"command\": \"<command>:<first_param>\", \"arg1\": \"<arg1>\", \"arg2\": \"<arg2>\", \"arg3\": \"<arg3>\", \"arg4\": \"<arg4>\", \"arg5\": \"<arg5>\" }`");
    } else {
        cli_info("Type a Command and then up to 6 arguments, like this: `funk <command:first_param> <arg1> <arg2> <arg3> <arg4> <arg5> <arg6>`");
    }
}

//------ Entry point for the CLI commands where one of the commands are "make:" that is ------
// used to CREATE Function Files (either single anonymous ones or files with named functions).
// Begin by getting a valid command structure by "command:first_param"
// and split it into parts that can then be used to determine next step
$cmd = '';
$firstParam = '';
$tableRegex = '/^([a-z][a-z0-9_]*)(,[a-z][a-z0-9_]*)*$/i';
$methodRouteRegex = '/^(([a-z]+\/)|([a-z]+(\/[:]?[a-zA-Z0-9]+)+))$/i';
$fileWithOptionalFnRegex = '/^([a-z][a-z0-9_]+)(=>([a-z0-9_.]+))?$/i';

// SPECIAL-CASE: Command to Recompile
// Routes File & Trie-based Route File
if ($command === 'recompile' || $command === 'rc') {
    cli_sort_build_routes_compile_and_output($singleRoutesRoute);
    return; // Needed since function NEVER exits script on success!
}

// Validate correct command and first param format
// Then extract them and just safety-check them again
if (!preg_match('/^([a-z]+):([a-z0-9_-]+)$/i', $command, $matches)) {
    cli_err_syntax("Invalid command format! Please use the format `command:first_param` with up to 6 arguments!");
    if (JSON_MODE) {
        cli_info("Use the following JSON format: `{ \"command\": \"<command>:<first_param>\", \"arg1\": \"<arg1>\", \"arg2\": \"<arg2>\", \"arg3\": \"<arg3>\", \"arg4\": \"<arg4>\", \"arg5\": \"<arg5>\", \"arg6\": \"<arg6>\" }`");
    } else {
        cli_info("Type a Command and then up to 6 arguments, like this: `funk <command:first_param> <arg1> <arg2> <arg3> <arg4> <arg5> <arg6>`");
    }
} else {
    $cmd = $matches[1] ?? null;
    $firstParam = $matches[2] ?? null;
}
if (!isset($cmd) || !is_string($cmd) || empty($cmd)) {
    cli_err_syntax_without_exit("Command must be a Non-Empty String! Please provide a valid Command with up to 6 arguments!");
    if (JSON_MODE) {
        cli_info("Use the following JSON format: `{ \"command\": \"<command>:<first_param>\", \"arg1\": \"<arg1>\", \"arg2\": \"<arg2>\", \"arg3\": \"<arg3>\", \"arg4\": \"<arg4>\", \"arg5\": \"<arg5>\", \"arg6\": \"<arg6>\" }`");
    } else {
        cli_info("Type a Command and then up to 6 arguments, like this: `funk <command:first_param> <arg1> <arg2> <arg3> <arg4> <arg5> <arg6>`");
    }
}
if (!isset($firstParam) || !is_string($firstParam) || empty($firstParam)) {
    cli_err_syntax_without_exit("First Parameter must be a Non-Empty String! Please provide a valid First Parameter.");
    if (JSON_MODE) {
        cli_info("Use the following JSON format: `{ \"command\": \"<command>:<first_param>\", \"arg1\": \"<arg1>\", \"arg2\": \"<arg2>\", \"arg3\": \"<arg3>\", \"arg4\": \"<arg4>\", \"arg5\": \"<arg5>\", \"arg6\": \"<arg6>\" }`");
    } else {
        cli_info("Type a Command and then up to 6 arguments, like this: `funk <command:first_param> <arg1> <arg2> <arg3> <arg4> <arg5> <arg6>`");
    }
}

// MAKE: Create something new and OPTIONALLY adding it to a specific Method/Route
if ($cmd === "make" || $cmd === "create" || $cmd === "new") {
    $middlewaresAliases = ['mw', 'mws', 'middlewares', 'middleware'];
    $singlePipelineAliases = ['pl', 'pls', 'pipeline', 'pipelines'];
    $validationAliases = ['v', 'validation'];
    $sqlAliases = ['sql', 's'];
    $routeAliases = ['route', 'r', 'rutt']; // "rutt" Swedish Easter Egg for "Route" in Swedish
    $folderListThatNeedsTables = ['sql', 'validation', 'v', 's'];
    $folderListThatWillCauseWarning = [
        'routes',
        'cached',
        'backups',
        '_final_backups',
        'valid',
        'complete',
        'functions',
        'compiled',
        'components',
        'partials',
        'blocked',
        'config',
        '_internals',
        'batteries',
        'post-request',
        'request',
        'gui',
        'public_html',
        'cli',
        'test',
        'tests',
        'schema',
        'schemas',
    ];
    $ROUTES = $singleRoutesRoute['ROUTES'];

    // Issue a warning but still continue if the first parameter is in the list of folders that will cause a warning
    // because these folders are already being used for other purposes but they could be used inside of "funkphp/routes/"
    // which is where they will be put!
    if (in_array($firstParam, $folderListThatWillCauseWarning)) {
        cli_warning_without_exit("The first parameter `$firstParam` is in the list of Folders that are already being used by FunkPHP. Despite this, `$firstParam` will be used as a subfolder in `funkphp/routes/`!");
        cli_info_without_exit("This is just a heads-up so you are not confused by seeing a folder with the same name in several places inside of FunkPHP!");
    }

    // Structure the correct folder name based on the first parameter,
    // $folderType based on first parameter, and also initial $routeKey
    // $routeKey is only applicable to "routes" and "middlewares"!
    $folder = null;
    $routeKey = null;
    $anonymousFile = false;
    $folderType = null;
    $tablesProvided = null;
    $file = null;
    $fn = null;
    $routeOnly = false;
    if (in_array($firstParam, $middlewaresAliases)) {
        $folder = "funkphp/middlewares";
        $folderType = "middlewares";
        $routeKey = ["middlewares" => null];
        $anonymousFile = true; // Middlewares are always single anonymous function files
        [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1, "m_");
        cli_info_without_exit("OK! Middleware Files. Middleware Functions are recommended to be reused in different projects, so the File Name is suffixed with `_v1` indicating a versioned file. Change this later if needed. Run `funk recompile|rc` if you have manually added the Middleware Function File to a `Middlewares` Route Key to a given Route!");
        $routeKey[key($routeKey)] = $file;
    } elseif (in_array($firstParam, $singlePipelineAliases)) {
        $folderType = "pipeline";
        $folder = "funkphp/pipeline";
        $anonymousFile = true; // Pipeline functions are always single anonymous function files
        [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1, "pl_");
        cli_info_without_exit("OK! Pipeline File. Pipeline Functions are recommended to be reused in different projects, so the File Name is suffixed with `_v1` indicating a versioned file. Change this later if needed. Drag this Function File into either `funkphp/pipeline/request/` OR `funkphp/pipeline/post-request/` and then add it manually to the corresponding Pipeline Sub-Array! (`pipeline['request']` or `pipeline['post-request']`)");
    } elseif (in_array($firstParam, $validationAliases)) {
        $folderType = "validation";
        $folder = "funkphp/validation";
        [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1, "v_");
        cli_info_without_exit("OK! Validation File and/or Validation Function. These are recommended to be used by calling `funk_use_valdation(&\$c,\$file_name,\$file_fn)` inside an Anonymous Function OR a File=>Function File!");
    } elseif (in_array($firstParam, $sqlAliases)) {
        $folderType = "sql";
        $folder = "funkphp/sql";
        [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1, "s_");
        cli_info_without_exit("OK! SQL File and/or SQL Function. These are recommended to be used by first calling `funk_load_sql(&\$c,\$file_name,\$file_fn)` and then `funk_use_sql(&\$c,\$loadedSQLArray,\$optionalInputData,\$hydrateAfterQuery)` inside an Anonymous Function OR a File=>Function File!");
    }
    // This is a special case where we only create
    // a Route for `funkphp/routes/routes.php`!
    elseif (in_array($firstParam, $routeAliases)) {
        $routeOnly = true;
        cli_info_without_exit("OK! Creating a Route to `funkphp/routes/routes.php` unless it already exists. After this, you can add Route Keys to that created Route!");
    } else {
        $folderType = "routes";
        $folder = "funkphp/routes" . '/' . $firstParam;
        $routeKey = [$firstParam => null];
        [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1);
        $routeKey[key($routeKey)] = [$file => $fn];
        cli_info_without_exit("OK! A Route File and/or Route Function that will be placed inside:`$folder`. If you provided a Method/Route it will be automatically added IF it is sucessfully created! Otherwise, you will have to manually add it to a Route Key of a Route manually or by running `funk add:$firstParam $file=>$fn <method/route>`!");
    }

    // Passing $arg2 for Method/Route is optional so we check if it is set
    $method = null;
    $route = null;
    // SPECIAL_CASE: Only adding a Route to `funkphp/routes/routes.php`, so this
    // part will run and either Fail or Succeed and then exit the script!
    if ($routeOnly) {
        if (!isset($arg1) || !is_string($arg1) || empty($arg1) || !preg_match($methodRouteRegex, $arg1)) {
            cli_err_without_exit("No Valid Method/Route provided when wanting to only Create a New Route! `($cmd:$firstParam)`");
            cli_info_without_exit("Syntax is: `funk make:r method/route` like `funk make:r g/users` OR `funk make:r post/users`!");
            cli_info("Notice the support for shorthand versions \"g\", \"po\", \"pu\", \"d\" OR \"del\", \"pa\" for GET, POST, PUT, DELETE and PATCH respectively!");
        }
        [$method, $route] =  cli_return_valid_method_n_route_or_err_out($arg1);

        // We tell that other arguments will be ignored since we
        // are only adding a Route to `funkphp/routes/routes.php`
        if (isset($arg2) || isset($arg3) || isset($arg4) || isset($arg5) || isset($arg6)) {
            cli_warning_without_exit("Ignoring other arguments (\$'arg2' to \$'arg6') since this Command ONLY adds a New Route to `funkphp/routes/routes.php`!");
        }

        // If Method is not set, we create it even though it should actually exist
        // and then we can also just add the Route to it and be done with it!
        if (!array_key_exists($method, $ROUTES)) {
            $ROUTES[$method] = [];
            $ROUTES[$method][$route] = [];
            cli_info_without_exit("Added New Method and New Route to it... Attempting to rebuild the Trie & Route File Now... If it fails, the Route will NOT have been added and you will have to try again!");
            cli_sort_build_routes_compile_and_output(["ROUTES" => $ROUTES]);
            cli_success_without_exit("Created New Valid Method `$method` in `funkphp/routes/routes.php`!");
            cli_success_without_exit("Created Method/Route `$method$route` in `funkphp/routes/routes.php`!");
            cli_info("You can now add Route Keys to this Route by running `funk add:subfolder_in_funkphp File=>Function $method$route`!");
        }
        // "else" means Method exist, but we do not know if Route exists in that Method
        else {
            if (array_key_exists($route, $ROUTES[$method])) {
                cli_err_without_exit("Route `$method$route` already exists in `funkphp/routes/routes.php`! Please provide a different Route OR Method/Route!");
                cli_info("You can add Route Keys to this Route by running `funk add:subfolder_in_funkphp File=>Function $method$route`!");
            } else {
                // Check against conflicting Dynamic Routes when they are on the same URI Segment level at the end
                // For example: `GET/users/:id` and `GET/users/:id2` because they are on the same level at the end
                $troute = include_once $exactFiles['troute_route'];
                $findDynamicRoute = cli_match_developer_route($method, $route, $troute, $ROUTES, $ROUTES);
                if ($findDynamicRoute['route'] !== null) {
                    cli_err_without_exit("Found Dynamic Route \"{$findDynamicRoute['method']}{$findDynamicRoute['route']}\" in Trie Routes would conflict with \"$method$route\".");
                    cli_info("Run `php funk recompile|rc` to rebuild Trie Routes if you manually removed that Route you want to add again!");
                }

                // Here a new Route is added to the Method because it does not already exist
                $ROUTES[$method][$route] = [];
                cli_info_without_exit("Added New Route `$route` to Method `$method` in `funkphp/routes/routes.php`... Attempting to rebuild the Trie & Route File Now... If it fails, the Route will NOT have been added and you will have to try again!");
                cli_sort_build_routes_compile_and_output(["ROUTES" => $ROUTES]);
                cli_success_without_exit("Created Method/Route `$method$route` in `funkphp/routes/routes.php`!");
                cli_info("You can now add Route Keys to this Route by running `funk add:subfolder_in_funkphp File=>Function $method$route`!");
            }
        }
    } // END OF SPECIAL_CASE: Only adding a Route to `funkphp/routes/routes.php`

    if (isset($arg2) && is_string($arg2) && !empty($arg2) && preg_match($methodRouteRegex, $arg2)) {
        if ($folderType !== "middlewares" && $folderType !== "routes") {
            cli_warning_without_exit("$folder does NOT use Method/Route so `$arg2` Is Ignored!");
        } else {
            [$method, $route] =  cli_return_valid_method_n_route_or_err_out($arg2);
        }
    } else {
        if ($folderType === "middlewares" || $folderType === "routes") {
            cli_info_without_exit("No Method/Route provided! Created File and/or Function inside of `/funkphp/routes` OR `funkphp/middlewares` will NOT be attached to a Method/Route!");
        }
    }

    // $folderType "validation" & "sql" demands $arg2 OR $arg3 to be a string of "tables"
    if ($folderType === 'validation' || $folderType === 'sql') {
        if (
            isset($arg2) && is_string($arg2) && !empty($arg2) && preg_match($tableRegex, $arg2)
        ) {
            $tablesProvided = $arg2;
        } elseif (
            isset($arg3) && is_string($arg3) && !empty($arg3) && preg_match($tableRegex, $arg3)
        ) {
            $tablesProvided = $arg3;
        } else {
            cli_err_syntax_without_exit("Provide Valid Table Name(s) as second (\"arg2\") or third (\"arg3\") argument for `$folderType` Folder Type!");
            cli_info_without_exit("Use either Format:`table1` for Single Table OR:`table1,table2,etc3` for Multiple Tables!");
            cli_info("Regex for Valid Table Names: `/^([a-z][a-z0-9_]*)(,[a-z][a-z0-9_]*)*$/i`!");
        }
    }
    // Grab status for the folder and file so we can check whether
    // we can even access it, if it exists, is writable, etc.
    $statusArray = cli_folder_and_php_file_status($folder, $file);
    var_dump($file, $fn, $method, $route, $folder, $routeKey);

    // NO METHOD & ROUTE WAS PROVIDED - This is automatically
    // forced when making/creating "pipeline"/"sql"/"validation"
    // but it can also be manually set to null (not provided)
    $createStatus = null;
    if (!$method && !$route) {
        if ($folderType === 'pipeline') {
            $createStatus = cli_crud_folder_and_php_file($statusArray, "create_new_anonymous_file", $file, null, "pipeline");
            if ($createStatus) {
                cli_success_without_exit("SUCCESSFULLY Created Single Anonymous Function File `$file.php` in Folder `$folder`!");
                cli_info("The Pipeline File `$file.php` is now ready to be used in your Pipeline - place it first either in `funkphp/pipeline/request/` OR `funkphp/pipeline/post-request/` and then add it to the corresponding Pipeline Sub-Array! (`pipeline['request']` or `pipeline['post-request']`)");
            } else {
                cli_err("FAILED to Create Single Anonymous Function File `$file.php` in Folder `$folder`!");
            }
        } elseif ($folderType === 'middlewares') {
            $createStatus = cli_crud_folder_and_php_file($statusArray, "create_new_anonymous_file", $file, null, "middlewares");
            if ($createStatus) {
                cli_success_without_exit("SUCCESSFULLY Created Single Anonymous Function File `$file.php` in Folder `$folder`!");
                cli_info_without_exit("The Middlewares File `$file.php` is now ready to be used in your Routes. You did not provide a Method/Route so it will not be automatically added to any Route. You can add it manually later on!");
                if (JSON_MODE) {
                    cli_info("Add it manually with the following JSON Syntax: `{ \"command\": \"add:middlewares\", \"arg1\": \"$file\", \"arg2\": \"<method/route>\" }`");
                } else {
                    cli_info("Add it manually in the CLI by typing `funk add:middlewares $file <method/route>`!");
                }
            } else {
                cli_err("FAILED to Create Single Anonymous Function File `$file.php` in Folder `$folder`!");
            }
        } // TODO: Fix next - REMEMBER that there is NO METHOD/ROUTE provided here!
        elseif ($folderType === 'routes') {
            // If folder path does not exist, we attempt creating it which also means
            // that file and its fn does NOT exist so we will pass crudType "create_new_file_and_fn"
            if (!$statusArray['folder_path']) {
                if (!mkdir(PROJECT_DIR . '/' . $folder, 0755, true)) {
                    cli_err("FAILED to Create Folder `$folder`! Verify File Permissions and try again.");
                }
                $createStatus = cli_crud_folder_and_php_file($statusArray, "create_new_file_and_fn", $file, $fn, "routes");
                if ($createStatus) {
                    cli_success_without_exit("SUCCESSFULLY Created File `$file.php` with Function `$fn` in Folder `$folder`!");
                    cli_info_without_exit("The Route File `$file.php` is now ready to be used in your Routes. You did not provide a Method/Route so it will not be automatically added to any Route. You can add it manually later on!");
                    if (JSON_MODE) {
                        cli_info("Add it manually with the following JSON Syntax: `{ \"command\": \"add:$firstParam\", \"arg1\": \"$file=>$fn\", \"arg2\": \"<method/route>\" }`");
                    } else {
                        cli_info("Add it manually in the CLI by typing `funk add:$firstParam $file=>$fn <method/route>`!");
                    }
                } else {
                    cli_err("FAILED to Create File `$file.php` with Function `$fn` in Folder `$folder`!");
                }
            }  // Here crudType is "create_only_new_fn_in_file" unless the file does not exist
            else {
                // File does not exist meaning crudType "create_new_file_and_fn"
                if (!$statusArray['file_exists']) {
                    $createStatus = cli_crud_folder_and_php_file($statusArray, "create_new_file_and_fn", $file, $fn, "routes");
                    if ($createStatus) {
                        cli_success_without_exit("SUCCESSFULLY Created File `$file.php` with Function `$fn` in Folder `$folder`!");
                        cli_info_without_exit("The Route File `$file.php` is now ready to be used in your Routes. You did not provide a Method/Route so it will not be automatically added to any Route. You can add it manually later on!");
                        if (JSON_MODE) {
                            cli_info("Add it manually with the following JSON Syntax: `{ \"command\": \"add:$firstParam\", \"arg1\": \"$file=>$fn\", \"arg2\": \"<method/route>\" }`");
                        } else {
                            cli_info("Add it manually in the CLI by typing `funk add:$firstParam $file=>$fn <method/route>`!");
                        }
                    } else {
                        cli_err("FAILED to Create File `$file.php` with Function `$fn` in Folder `$folder`!");
                    }
                }
                // crudType is now "create_only_new_fn_in_file" since file exists
                // unless function already exists in the file!
                else {
                    // Function already exists in the file
                    if (isset($statusArray['functions'][$fn])) {
                        cli_err_without_exit("Function `$fn` already exists in File `$file.php` in Folder `$folder`!");
                        cli_info("Change File and/or Function Name and try again for `$folder`!");
                    }
                    // Function does not exist in the file so
                    // crudType "create_only_new_fn_in_file"
                    else {
                        $createStatus = cli_crud_folder_and_php_file($statusArray, "create_only_new_fn_in_file", $file, $fn, "routes");
                        if ($createStatus) {
                            cli_success_without_exit("SUCCESSFULLY Created Function `$fn` in File `$file.php` in Folder `$folder`!");
                            cli_info_without_exit("The Route File `$file.php` is now ready to be used in your Routes. You did not provide a Method/Route so it will not be automatically added to any Route. You can add it manually later on!");
                            if (JSON_MODE) {
                                cli_info("Add it manually with the following JSON Syntax: `{ \"command\": \"add:$firstParam\", \"arg1\": \"$file=>$fn\", \"arg2\": \"<method/route>\" }`");
                            } else {
                                cli_info("Add it manually in the CLI by typing `funk add:$firstParam $file=>$fn <method/route>`!");
                            }
                        } else {
                            cli_err("FAILED to Create Function `$fn` in File `$file.php` in Folder `$folder`!");
                        }
                    }
                }
            }
        } elseif ($folderType === 'validation') {
            if (!$statusArray['folder_path']) {
                cli_err_without_exit("This Folder SHOULD ALWAYS EXIST due to the nature of FunkPHP and its FunkCLI which auto-generates Default Folder on each Command!!");
                cli_info("Verify File Permissions for Subfolders in `funkphp/` and try again since this Folder should be recreated each time your run a Command to the FunkCLI!");
            }
        } elseif ($folderType === 'sql') {
            if (!$statusArray['folder_path']) {
                cli_err_without_exit("This Folder SHOULD ALWAYS EXIST due to the nature of FunkPHP and its FunkCLI which auto-generates Default Folder on each Command!");
                cli_info("Verify File Permissions for Subfolders in `funkphp/` and try again since this Folder should be recreated each time your run a Command to the FunkCLI!");
            }
        }
        // Impossible edge-case
        else {
            cli_err("You are trying to create a File Name with a Function Name in a Folder Type that is NOT supported!");
        }
    }
    // A VALID METHOD & ROUTE WAS PROVIDED - This means we might need to add it to
    // a matched Method/Route in the Routes File unless it already exists there!
    // Anonymous Function "pipeline" Files does not apply, but "middlewares" does
    elseif ($method && $route) {
        if ($folderType === 'routes') {
        } elseif ($folderType === 'middlewares') {
        } else {
            cli_err("You are trying to create a File Name with a Function Name in a Folder Type that is NOT supported!");
        }
    }
    // Impossible edge-case where either $method or $route
    // is not set when both should be either set or not set
    else {
        cli_err("Impossible Edge-Case where either \$method OR \$route is NOT SET when both either should be set or both should be null!");
    }
}
// ADD: Attach a Route_Key that already exists to a specific Method/Route
// assuming the Method/Route and/or the File+Function already exists
elseif ($cmd === "add" || $cmd === "attach" || $cmd === "link") {
    $middlewaresAliases = ['mw', 'mws', 'middlewares'];
    $singlePipelineAliases = ['pl', 'pls', 'pipeline'];
    $singleAnonymousFolderlist = ["middlewares", "mw", "mws", "pls", "pl", "pipeline"];
    $folderListThatNeedsTables = ['sql', 'validation', 'validation', 'v', 's'];
    $folderListThatWillCauseWarning = [
        'routes',
        'cached',
        'backups',
        '_final_backups',
        'valid',
        'complete',
        'functions',
        'compiled',
        'components',
        'partials',
        'blocked',
        'config',
        '_internals',
        'batteries',
        'post-request',
        'request',
        'gui',
        'public_html',
        'cli',
        'test',
        'tests',
        'schema',
        'schemas',
    ];

    // Issue a warning but still continue if the first parameter is in the list of folders that will cause a warning
    // because these folders are already being used for other purposes but they could be used inside of "funkphp/routes/"
    // which is where they will be put!
    if (in_array($firstParam, $folderListThatWillCauseWarning)) {
        cli_warning_without_exit("The first parameter `$firstParam` is in the list of Folders that are already being used by FunkPHP. It will now be used as a subfolder in `funkphp/routes/`!");
        cli_info_without_exit("This is just a heads-up so you are not confused by seeing a folder with the same name in several places inside of FunkPHP!");
    }

    // Extract valid $file and $fn from $arg1
    [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1);
    $method = null;
    $route = null;
    // Passing $arg2 for Method/Route is optional so we check if it is set
    if (isset($arg2) && is_string($arg2) && !empty($arg2)) {
        [$method, $route] =  cli_return_valid_method_n_route_or_err_out($arg2);
    } else {
        cli_info_without_exit("No Method/Route provided! This means any created Function File and/or Function Name inside of /funkphp/routes/ will NOT be attached to any Method/Route!");
    }
    var_dump($file, $fn, $method, $route);

    exit;
}
// REMOVE: Remove an added Route_Key from a specific Method/Route
// found in "/funkphp/routes" OR in "/funkphp/middlewares".
elseif ($cmd === "remove"  || $cmd === "rm" || $cmd === "detach") {
    $middlewaresAliases = ['mw', 'mws', 'middlewares'];
    $singlePipelineAliases = ['pl', 'pls', 'pipeline'];
    $singleAnonymousFolderlist = ["middlewares", "mw", "mws", "pls", "pl", "pipeline"];
    $folderListThatNeedsTables = ['sql', 'validation', 'validation', 'v', 's'];
    $folderListThatWillCauseWarning = [
        'routes',
        'cached',
        'backups',
        '_final_backups',
        'valid',
        'complete',
        'functions',
        'compiled',
        'components',
        'partials',
        'blocked',
        'config',
        '_internals',
        'batteries',
        'post-request',
        'request',
        'gui',
        'public_html',
        'cli',
        'test',
        'tests',
        'schema',
        'schemas',
    ];

    // Issue a warning but still continue if the first parameter is in the list of folders that will cause a warning
    // because these folders are already being used for other purposes but they could be used inside of "funkphp/routes/"
    // which is where they will be put!
    if (in_array($firstParam, $folderListThatWillCauseWarning)) {
        cli_warning_without_exit("The first parameter `$firstParam` is in the list of Folders that are already being used by FunkPHP. It will now be used as a subfolder in `funkphp/routes/`!");
        cli_info_without_exit("This is just a heads-up so you are not confused by seeing a folder with the same name in several places inside of FunkPHP!");
    }

    // Extract valid $file and $fn from $arg1
    [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1);
    $method = null;
    $route = null;
    // Passing $arg2 for Method/Route is optional so we check if it is set
    if (isset($arg2) && is_string($arg2) && !empty($arg2)) {
        [$method, $route] =  cli_return_valid_method_n_route_or_err_out($arg2);
    } else {
        cli_info_without_exit("No Method/Route provided! This means any created Function File and/or Function Name inside of /funkphp/routes/ will NOT be attached to any Method/Route!");
    }
    var_dump($file, $fn, $method, $route);

    exit;
}
// DELETE: Delete something that exists which is either a Function File,
// or a Specific Function from a Specific File. NEVER deletes Method/Route!
elseif ($cmd === "delete" || $cmd === "del" || $cmd === "destroy") {
    $middlewaresAliases = ['mw', 'mws', 'middlewares'];
    $singlePipelineAliases = ['pl', 'pls', 'pipeline'];
    $singleAnonymousFolderlist = ["middlewares", "mw", "mws", "pls", "pl", "pipeline"];
    $folderListThatNeedsTables = ['sql', 'validation', 'validation', 'v', 's'];
    $folderListThatWillCauseWarning = [
        'routes',
        'cached',
        'backups',
        '_final_backups',
        'valid',
        'complete',
        'functions',
        'compiled',
        'components',
        'partials',
        'blocked',
        'config',
        '_internals',
        'batteries',
        'post-request',
        'request',
        'gui',
        'public_html',
        'cli',
        'test',
        'tests',
        'schema',
        'schemas',
    ];

    // Issue a warning but still continue if the first parameter is in the list of folders that will cause a warning
    // because these folders are already being used for other purposes but they could be used inside of "funkphp/routes/"
    // which is where they will be put!
    if (in_array($firstParam, $folderListThatWillCauseWarning)) {
        cli_warning_without_exit("The first parameter `$firstParam` is in the list of Folders that are already being used by FunkPHP. It will now be used as a subfolder in `funkphp/routes/`!");
        cli_info_without_exit("This is just a heads-up so you are not confused by seeing a folder with the same name in several places inside of FunkPHP!");
    }

    // Extract valid $file and $fn from $arg1
    [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1);
    $method = null;
    $route = null;
    // Passing $arg2 for Method/Route is optional so we check if it is set
    if (isset($arg2) && is_string($arg2) && !empty($arg2)) {
        [$method, $route] =  cli_return_valid_method_n_route_or_err_out($arg2);
    } else {
        cli_info_without_exit("No Method/Route provided! This means any created Function File and/or Function Name inside of /funkphp/routes/ will NOT be attached to any Method/Route!");
    }
    var_dump($file, $fn, $method, $route);

    exit;
}
// COMPILE: Compiles a Validation OR SQL File by using its $DX variable
// and (re)genereating a new return (); in the same Validation/SQL File.
// "_eval" is included so the Developer realizes that the eval() function
// will be used as part of this command to compile the file!
elseif ($cmd === "compile" || $cmd === "comp" || $cmd === "cp") {
    $validFirstParams = ['validation_eval', 'v_eval', 'sql_eval', 's_eval'];
    $validationAliases = ['v_eval', 'validation_eval'];
    $sqlAliases = ['sql_eval', 's_eval'];
    // Validate $firstParam is one of the valid
    // first parameters and then grab $file=>$fn
    if (!in_array($firstParam, $validFirstParams)) {
        cli_err_syntax_without_exit("Invalid first parameter! Please provide a valid first parameter for the `compile` command, either `validation`, `v`, `sql`, or `s` ending with `_eval` since eval() function is needed for this command to run!");
        if (JSON_MODE) {
            cli_info("Use the following JSON format: `{ \"command\": \"compile:<first_param>\", \"arg1\": \"<arg1>\" }`");
        } else {
            cli_info("Type a Command and then up to 6 arguments, like this: `funk compile:<first_param> <arg1>`");
        }
    }
    if (str_starts_with($firstParam, "v")) {
        [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1, "v_");
    } elseif (str_starts_with($firstParam, "s")) {
        [$file, $fn] = cli_return_valid_file_n_fn_or_err_out($arg1, "s_");
    }
    // Compile based on Validation OR SQL File,
    // also handle impossible edge-case!
    // IF Compile VALIDATION
    if (in_array($firstParam, $validationAliases)) {
        $statusArray = cli_folder_and_php_file_status("funkphp/validation", $file);
        // File_path must exist, otherwise we cannot write
        // to it as part of the completed compile process
        if (!$statusArray['file_path']) {
            cli_err("Validation File Path `funkphp/validation/$file.php` does NOT Exist! Provide a Valid Validation File=>Function to Compile where the Exact File Path also exists!");
        }
        // Validate file exists, is readable, writable, and contains the correct function
        // and that its $DX variable is set and also its return array is set so both can be used!
        if (!$statusArray['file_exists']) {
            cli_err("Validation File `funkphp/validation/$file.php` does NOT Exist in `funkphp/validation`! Provide a valid Validation File=>Function to Compile!");
        }
        if (!$statusArray['file_readable']) {
            cli_err("Validation File `funkphp/validation/$file.php` is NOT Readable! Please check the File Permissions and try again!");
        }
        if (!$statusArray['file_writable']) {
            cli_err("Validation File `funkphp/validation/$file.php` is NOT Writable! Please check the File Permissions and try again!");
        }
        if (!isset($statusArray["functions"][$fn])) {
            cli_err("Validation File `funkphp/validation/$file.php` does NOT contain a Function named `$fn`! Please provide a Valid Function Name inside `$file.php` to Compile!");
        }
        if (!isset($statusArray["functions"][$fn]['dx_raw'])) {
            cli_err_without_exit("Validation Function `$fn` inside File `funkphp/validation/$file.php` does NOT contain a \$DX Variable which should be an Array! Please provide a Valid \$DX Variable inside the Function `$fn` to Compile!");
            cli_info("Make sure it is indented using CMD+S or CTRL+S to autoformat the Validation File!");
        }
        if (!isset($statusArray["functions"][$fn]['return_raw'])) {
            cli_err_without_exit("Validation Function `$fn` inside File `funkphp/validation/$file.php` does NOT contain the needed return array()! Please provide a Valid return Array inside the Function `$fn` to Compile!");
            cli_info("Make sure it is indented using CMD+S or CTRL+S to autoformat the Validation File!");
        }

        // Attempt using eval() to extract the $DX variable which should be parsed as a valid PHP Array
        $matchedSimpleSyntax = $statusArray["functions"][$fn]['dx_raw'];
        $matchedReturnStmt = $statusArray["functions"][$fn]['return_raw'];
        $evalCode = null;
        try {
            $evalCode = "\nreturn $matchedSimpleSyntax";
            $evalCode = eval($evalCode);
        } catch (Throwable $e) {
            cli_err_without_exit("The \"\$DX\" variable was found but could not be parsed as a valid PHP Array!");
            cli_info_without_exit("Make sure it is intended using CMD+S or CTRL+S to autoformat the Validation Handler File!");
            cli_info("It must start as an array: `\$DX = ['<anything_inside_here>'];` or it will not be found.  Only single quotes `['<DXarray>']` are allowed!");
        }
        if ($evalCode === null) {
            cli_err_without_exit("The \"\$DX\" variable was found but could not be parsed as a valid PHP Array!");
            cli_info_without_exit("Make sure it is intended using CMD+S or CTRL+S to autoformat the Validation Handler File!");
            cli_info("It must start as an array: `\$DX = ['<anything_inside_here>'];` or it will not be found.  Only single quotes `['<DXarray>']` are allowed!");
        }
        if (is_array($evalCode)) {
            cli_info_without_exit("Found \"\$DX\" Variable Parsed as a Valid PHP Array!");
        }

        // This contains the optimized validation rules which will then replace the "$matchedReturnStmt"
        // The function can error out on its own so we do not need to check for the return value!
        $optimizedRuleArray = cli_convert_simple_validation_rules_to_optimized_validation($evalCode, $file, $fn);

        // Convert the optimized rule array to a string with ";\n" at the end
        $optimizedRuleArrayAsStringWithReturnStmt = "return " . var_export($optimizedRuleArray, true) . ";\n";

        // Copy of the Entire Function which contains BOTH the $DX and the return array
        $fileRawCopy = $statusArray["file_raw"]["entire"];
        $fnCopy = $statusArray["functions"][$fn]['fn_raw'];
        $fnReturnCopy = $statusArray["functions"][$fn]['return_raw'];
        $replaced = str_replace(
            $matchedReturnStmt,
            $optimizedRuleArrayAsStringWithReturnStmt,
            $fnCopy
        );
        $newFileRaw = str_replace(
            $fnCopy,
            $replaced,
            $fileRawCopy
        );
        $result = file_put_contents($statusArray['file_path'], $newFileRaw);
        if ($result === false) {
            cli_err("FAILED to Write the Compiled Optimized Validation Rules to the File `funkphp/validation/$file.php`! Verify File Permissions and try again!");
        } else {
            cli_success_without_exit("SUCCESSFULLY COMPILED Validation Rules to Optimized Rules in Validation Function \"$fn\" in \"funkphp/validation/$file.php\".");
            cli_info("IMPORTANT: Open it in an IDE and press CMD+S or CTRL+S to autoformat the Validation File again!");
        }
    }
    // IF Compile SQL
    elseif (in_array($firstParam, $sqlAliases)) {
        $statusArray = cli_folder_and_php_file_status("funkphp/sql", $file);
        // File_path must exist, otherwise we cannot write
        // to it as part of the completed compile process
        if (!$statusArray['file_path']) {
            cli_err("SQL File Path `funkphp/sql/$file.php` does NOT Exist! Provide a Valid SQL File=>Function to Compile where the Exact File Path also exists!");
        }
        // Validate file exists, is readable, writable, and contains the correct function
        // and that its $DX variable is set and also its return array is set so both can be used!
        if (!$statusArray['file_exists']) {
            cli_err("SQL File `funkphp/sql/$file.php` does NOT Exist in `funkphp/sql`! Provide a valid SQL File=>Function to Compile!");
        }
        if (!$statusArray['file_readable']) {
            cli_err("SQL File `funkphp/sql/$file.php` is NOT Readable! Please check the File Permissions and try again!");
        }
        if (!$statusArray['file_writable']) {
            cli_err("SQL File `funkphp/sql/$file.php` is NOT Writable! Please check the File Permissions and try again!");
        }
        if (!isset($statusArray["functions"][$fn])) {
            cli_err("SQL File `funkphp/sql/$file.php` does NOT contain a Function named `$fn`! Please provide a Valid Function Name inside `$file.php` to Compile!");
        }
        if (!isset($statusArray["functions"][$fn]['dx_raw'])) {
            cli_err_without_exit("SQL Function `$fn` inside File `funkphp/sql/$file.php` does NOT contain a \$DX Variable which should be an Array! Please provide a Valid \$DX Variable inside the Function `$fn` to Compile!");
            cli_info("Make sure it is indented using CMD+S or CTRL+S to autoformat the SQL File!");
        }
        if (!isset($statusArray["functions"][$fn]['return_raw'])) {
            cli_err_without_exit("SQL Function `$fn` inside File `funkphp/sql/$file.php` does NOT contain the needed return array()! Please provide a Valid return Array inside the Function `$fn` to Compile!");
            cli_info("Make sure it is indented using CMD+S or CTRL+S to autoformat the SQL File!");
        }

        // Attempt using eval() to extract the $DX variable which should be parsed as a valid PHP Array
        $matchedSimpleSyntax = $statusArray["functions"][$fn]['dx_raw'];
        $matchedReturnStmt = $statusArray["functions"][$fn]['return_raw'];
        $evalCode = null;
        try {
            $evalCode = "\nreturn $matchedSimpleSyntax";
            $evalCode = eval($evalCode);
        } catch (Throwable $e) {
            cli_err_without_exit("The \"\$DX\" variable was found but could not be parsed as a valid PHP Array!");
            cli_info_without_exit("Make sure it is intended using CMD+S or CTRL+S to autoformat the SQL Handler File!");
            cli_info("It must start as an array: `\$DX = ['<anything_inside_here>'];` or it will not be found.  Only single quotes `['<DXarray>']` are allowed!");
        }
        if ($evalCode === null) {
            cli_err_without_exit("The \"\$DX\" variable was found but could not be parsed as a valid PHP Array!");
            cli_info_without_exit("Make sure it is intended using CMD+S or CTRL+S to autoformat the SQL Handler File!");
            cli_info("It must start as an array: `\$DX = ['<anything_inside_here>'];` or it will not be found.  Only single quotes `['<DXarray>']` are allowed!");
        }
        if (is_array($evalCode)) {
            cli_info_without_exit("Found \"\$DX\" Variable Parsed as a Valid PHP Array!");
        }

        // This contains the optimized validation rules which will then replace the "$matchedReturnStmt"
        // The function can error out on its own so we do not need to check for the return value!
        $optimizedSQLArray = cli_convert_simple_sql_query_to_optimized_sql($evalCode, $file, $fn);

        // We validate the optimized SQL Query String by using the Prepared Statement that should not fail
        // If it fails, we will catch the exception and inform the Developer. It could fail due to actual
        // invalid SQL String Syntax or because of a mismatch between the Table Configuration in `tables.php`
        // and the actual Table in the MySQL DBMS (e.g. phpMyAdmin, Adminer, etc.) assuming it exists!
        $dbConnect =  cli_db_connect();
        $queryToTest = $optimizedSQLArray['sql'] ?? null;
        if ($queryToTest === null || !is_string_and_not_empty($queryToTest)) {
            cli_err_without_exit("The optimized SQL Query is Empty or NOT a Valid String in SQL Function \"$fn\" in \"$file.php\".");
            cli_info("Check if indeed the `sql` key was provided from the returned Optimized SQL Array Variable?");
        }
        try {
            cli_info_without_exit("Testing the Optimized SQL Query String from SQL Function \"$fn\" in \"$file.php\".");
            $stmt = $dbConnect->prepare($queryToTest);
        } catch (mysqli_sql_exception $e) {
            cli_err_without_exit("The Optimized SQL Query String FAILED during Statement Preparing (from SQL Function \"$fn\" in \"$file.php\").");
            cli_info_without_exit("This means either\n1) Actual invalid SQL String Syntax that somehow slipped through the Compilation Stage when it shouldn't have, or that \n2) The Table and its configuration added in `config/tables.php` DOES NOT MATCH the Table with the same name in your local MySQL DBMS (e.g. phpMyAdmin, Adminer, etc.) assuming it exists!");

            // We show some guessing info based on what "$e->getMessage()" contains.
            if (is_string($e->getMessage()) && str_contains($e->getMessage(), "Unknown column") && str_contains($e->getMessage(), "field list")) {
                cli_info_without_exit("MAYBE: The MySQLi Error might indicate a missing/misspelled Column Name OR You might need a JOIN with the Table that contains that `unknown column`. Also check your `FROM` Key that it includes the Table you want queried!");
            } elseif (is_string($e->getMessage()) && str_contains($e->getMessage(), "Table ")  && str_contains($e->getMessage(), "doesn't exist")) {
                cli_info_without_exit("MAYBE: The MySQLi Error might indicate that the Table does not exist in your local MySQL DBMS (e.g. phpMyAdmin, Adminer, etc.) or that you have a typo in the Table Name in your SQL Array!");
            } elseif (is_string($e->getMessage()) && str_contains($e->getMessage(), "Unknown column") && str_contains($e->getMessage(), "in 'where clause'")) {
                cli_info_without_exit("MAYBE: The MySQLi Error might indicate a missing/misspelled Column Name in the `WHERE` Clause of your SQL Query String. Check your `WHERE` Key in the SQL Array!");
            } elseif (is_string($e->getMessage()) && str_contains($e->getMessage(), "Unknown column")) {
            }

            cli_info("INTERNAL MySQLi ERROR: \"" . $e->getMessage() . "\"");
        }
        cli_success_without_exit("[COMPILED SQL STRING VALIDATED IN DBMS] The SQL Query String in SQL Function \"$fn\" in \"$file.php\" was Successfully Validated with 0 Errors When Sending it Prepared to the local MySQL DBMS!");
        cli_info_without_exit("Attempting adding the entire Optimized SQL Array as the returned value in SQL Function \"$fn\" in \"$file.php\"!");
        // Convert the optimized SQL array to a string with ";\n" at the end
        $optimizedSQLArrayAsStringWithReturnStmt = "return " . var_export($optimizedSQLArray, true) . ";\n";

        // Copy of the Entire Function which contains BOTH the $DX and the return array
        $fileRawCopy = $statusArray["file_raw"]["entire"];
        $fnCopy = $statusArray["functions"][$fn]['fn_raw'];
        $fnReturnCopy = $statusArray["functions"][$fn]['return_raw'];
        $replaced = str_replace(
            $matchedReturnStmt,
            $optimizedSQLArrayAsStringWithReturnStmt,
            $fnCopy
        );
        $newFileRaw = str_replace(
            $fnCopy,
            $replaced,
            $fileRawCopy
        );
        $result = file_put_contents($statusArray['file_path'], $newFileRaw);
        if ($result === false) {
            cli_err("FAILED compiling SQL Query to Optimized SQL in SQL Function \"$fn\" in \"$file.php\". Verify File Permissions and try again!");
        } else {
            cli_success_without_exit("[ENTIRE SQL ARRAY COMPILED] SUCCESSFULLY COMPILED SQL Query to Optimized SQL in SQL Function \"$fn\" in \"funkphp/sql/$file.php\".");
            cli_info("IMPORTANT: Open it in an IDE and press CMD+S or CTRL+S to autoformat the SQL Handler File again!");
        }
    }
    // ELSE IMPOSSIBLE EDGE-CASE
    else {
        cli_err("Impossible Edge-Case where \$firstParam is NOT a Valid Validation OR SQL File Type! Please provide a valid first parameter for the `compile` command, either `validation`, `v`, `sql`, or `s`!");
    }
}
// Catch any invalid commands that are not recognized
else {
    cli_err_syntax_without_exit("Invalid command! Please provide a valid command with up to 6 arguments!");
    if (JSON_MODE) {
        cli_info("Use the following JSON format: `{ \"command\": \"<command>:<first_param>\", \"arg1\": \"<arg1>\", \"arg2\": \"<arg2>\", \"arg3\": \"<arg3>\", \"arg4\": \"<arg4>\", \"arg5\": \"<arg5>\", \"arg6\": \"<arg6>\" }`");
    } else {
        cli_info("Type a Command and then up to 6 arguments, like this: `funk <command:first_param> <arg1> <arg2> <arg3> <arg4> <arg5> <arg6>`");
    }
}
